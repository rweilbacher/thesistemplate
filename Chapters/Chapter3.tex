% Chapter 1

\chapter{The key wants of safety-critical device manufacturers} % Main chapter title

\label{Chapter3} % For referencing the chapter elsewhere, use \ref{Chapter1} 

%----------------------------------------------------------------------------------------

% Define some commands to keep the formatting separated from the content 
\newcommand{\keyword}[1]{\textbf{#1}}
\newcommand{\tabhead}[1]{\textbf{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\file}[1]{\texttt{\bfseries#1}}
\newcommand{\option}[1]{\texttt{\itshape#1}}

%----------------------------------------------------------------------------------------

% REVIEW This section has two goals for each want: Explain what the want means and explain why it is important (if it is not self-evident) and maybe explain how it relates to other wants
% NOTE I specifically avoid talking about architecture in this section, maybe I'm actually sabotaging myself with that
% TODO Move intro from chapter 4 here
This list comprises the key wants that manufactures of safety-critical devices want to achieve, when engineering a device. A want can be understood as a business driver for device manufacturers. Fulfilling all wants to the best degree possible, would result in a perfect device. These idealized wants will be used to compare the hypervisor architecture to other device architectures and recommend the features to look for, when choosing a real-world hypervisor implementation.

In an ideal world each want could be satisfied individually but in reality they have complex interactions and need to be carefully balanced. The specifics of these interactions will be explored in more detail later.

Additionally they are not equally desirable for every device. Some devices, for example, might have less potential for causing damage and therefore need to adhere to less strict safety regulations. Therefore choosing the absolute safest architecture is not paramount for the devices success.

\section{Safety}
[This section is kind of a duplicate of a section in Chapter 1]
It is self-evident that safety is going to be a key want in the engineering process of safety-critical devices. A device that is considered safer is often going to have an edge over that of a competitor. Furthermore, a perfectly safe device protects the manufacturer from expensive lawsuits.

Because of this, it is often beneficial for the manufacturer to ensure higher safety than required. However, in terms of economic viability, there are even more critical wants, as will become clear in the next section.

\subsection{Regulatory compliance}
[This section is kind of a duplicate of a section in Chapter 1]
To protect the end-customer of safety-critical devices, most regulatory bodies implement rules that govern how safety-critical devices have to be engineered and what quality level they have to fulfill.
Failing to achieve this is even more costly than lawsuits, since it will disallow the manufacturer from selling the device in the first place. All regulatory bodies then allow the manufacturer to make adjustments to his compliance documentation but for most regulations itâ€™s not just enough to prove that the end result has a high level of quality, the engineering process itself needs to be of high quality as well. This means that it is normally completely infeasible to make a device safe in the eyes of the law, if it has not been developed with this goal from the start. 

And while regulatory bodies almost always find some problems in the compliance, fixing them will cost additional money and time and getting it right the first time is therefore desirable.

\subsection{Real-time requirements}
% NOTE I am only looking at it from a safety perspective but there can also be usability implications, specifically in the usability area.
As a special safety requirement, some devices have to guarantee that an event can be completed in a certain amount of time. This has a significant impact on the entire device architecture, from the hardware, through the operating system to the actual application. Which is why it deserves special consideration.

The actual time frame that has to be guaranteed can vary wildly and whether it is 500ms or 50ns does have an impact on how the device needs to be implemented. However, the analysis in the later parts of the thesis will focus more on the core architectural differences that make satisfying this requirement possible in the first place. 

\section{Lowest possible cost}
% TODO Remember to include the distinction between initial and life-cycle costs
% NOTE Is this assumption necessary for any point I will make?
% NOTE Maybe make it clear that the actual Kano analysis is not necessary. I'm just making a point on the theoretical level
There are conceivable edge cases where a company might decide to go through with an unprofitable device for strategic reasons. Prestige customers or the possibility for profitable long-term business come to  mind. But in the interest of simplicity this thesis will assume that the manufacturer wants every project to be directly profitable.

With this assumption in mind, every other want needs to be realized with the pressure of cost in mind. To analyze the architecture effects, cost will be split into multiple subcategories:
\paragraph{Development costs}
The biggest part of the development cost is based on how many developers work on the project, how  much they are paid and for how long they are working on the project. This is true for both hardware and software but the specific numbers may differ. 

If third-party software is used, the corresponding license costs are another factor. 
\paragraph{Hardware costs}
How much the hardware in the device costs can be very important in some projects. Most costs associated with development are one-time costs, while hardware costs have to be paid for each produced unit. Therefore, this is an especially important factor in devices that are produced in high volume.

\subsection{Optimal time to market \label{optimal-ttm}}
Time ultimately costs money but a faster development process can have additional benefits that will be examined in more detail. To help with this, we will lean on the categorization of functional requirements established by the Kano model \cite{KanoNoriaki.1984}\cite{ElmarSauerwein.1996}. According to the Kano model there are three types of functional requirements.
% TODO Add graph
\paragraph{Must-be requirements} \textquote{If these requirements are not fulfilled, the customer will be extremely dissatisfied. [...] Fulfilling
the must-be requirements will only lead to a state of "not dissatisfied"} \autocite{ElmarSauerwein.1996}

\paragraph{One-dimensional requirements} \textquote{With regard to these requirements, customer satisfaction is
proportional to the level of fulfillment.}\autocite{ElmarSauerwein.1996}

\paragraph{Attractive requirements} \textquote{Attractive requirements are
neither explicitly expressed nor expected by the customer. Fulfilling these requirements leads to more
than proportional satisfaction. If they are not met, however, there is no feeling of dissatisfaction.}\autocite{ElmarSauerwein.1996}

This analysis is only based on the theoretical concepts and does not mean a Kano model analysis needs to be carried out. Furthermore, one-dimensional requirements will not be further considered as they can be simplified to be must-be requirements below zero satisfaction and attractive above zero satisfaction. 

% TODO Maybe elaborate on TTM benefits
Projects typically have an ideal time to market [source] that maximizes potential revenue and units sold. If functionally takes less time to implement, more can be achieved within this ideal timeline. Especially, attractive requirements can be more easily considered and give the manufacturer and edge over his competitors. One way to reduce the time it takes to include functionality is to use third-party software, either free open-source or paid for. 

\section{As few faults as possible}
% TODO Also talk about fault severity. If an architecture doesn't reduce the total amount of faults but reduces the amount of faults that lead to defects or severe defects, it is still a win
% NOTE what is "possible"
% NOTE I exclusively mention software faults here!
% NOTE I think I accidentally took away some content from "Maintainability"
Faults are undesirable in any engineering environment but they are especially undesirable in safety-critical devices. They are inherently unpredictable and can incur significant costs, both directly through the cost it takes to find and fix them and indirectly through customer dissatisfaction among other things.

Reducing the amount of faults to a minimum has multiple dimensions. 
[I mention mostly how software architecture addresses these problems. I plan to bridge the gap between software architecture and general architecture in a previous sections. However, any hardware perspective would be very much appreciated!]
\paragraph{Reducing the frequency of fault implementation}
It is still the common understanding that all non-trivial software that isn't formally verified will contain faults \cite{Klein.2009}. But in the decades since the software crisis it has become evident that development processes and architectures can have a positive impact on how many bugs are built into the software \cite{Randell.1996}.  
\paragraph{Finding faults effectively}
But not just frequency of fault implementation can be improved by a strong architecture. After a significant period of sophisticated testing, almost all "hard" bugs will be found. That is bugs that can be found easily and reliably
with standard techniques. Most of the remaining bugs will be "soft" bugs, often called "Heisenbugs" \cite{Gray.1986}. Named after the Heisenberg uncertainty principal because they often disappear when you look for them. 

A system that can aid the discovery of these bugs, maybe through clever compartmentalization or logging, can save time and money.
\paragraph{Fixing faults effectively}
% TODO Find some sources that detail how software architectures positively affect this. Concepts like "information hiding" "interfaces" etc. apply. The book clean code might be a good source
Once a fault has been found it also has to be fixed. Software that is easy to modify usually utilizes the virtues of information hiding and similar  concepts [WIP]. Changing any line of code only has the readily apparent effect and no other part of the software is invisibly dependent on it.

How many work hours ultimately need to be invested into fixing the fault, really depends on the fault but a perfectly modifiable software will make it as easy as possible.
\subsection{The lowest possible fault severity}
% TODO Agree on a definition for fault, error, defect etc. and then come back to this
Having the smallest amount of faults possible is great but ideally these faults also cause the least amount of damage possible. 

% NOTE Does the explanation of why an informal definition is enough have a place here. Should I not mention it at all, should I explain it somewhere else?
If a fault never manifests in a defect in the first place it also can't cause any damage. If it does however result in a defect its severity can be informally specified by a couple of factors. Using a formal definition is of little use here, as a comprehensive quantitative analysis of fault severity for the hypervisor architecture is out of the scope of this thesis. An informal definition will be enough as a basis for analytic reasoning on a theoretical level.
\paragraph{Fault isolation}
% PHRASING first sentence 
Ideally,  a fault only affects the parts it absolutely has to. An unrecoverable defect in the USB driver, for example, would ideally only cause the USB port to stop working and nothing else. A negative example of this would be if the fault instead caused a kernel panic that prompted the entire system to go down immediately.
\paragraph{Fault tolerance}
% TODO Maybe at least explore some examples
This is typically referred to as fault tolerance. There are many ways to achieve this relating to both hardware and software [Link some sources]. [Some more examples will be explored in the analysis of the architectures]

\section{Engaged and satisfied employees}
This \textit{want} may seem odd at first [Is saying this unprofessional?] but employees are the ones that are ultimately responsible for the success and failure of the project.

If we take software tools as an example: The software could be difficult to work with or include many repetitive tasks. Repetitive tasks are shown to decrease efficiency and increase the chance for mistakes \cite{Wyatt.1937}. Additionally, depending on the cause for the dissatisfaction it can also be indicative of problems that could them self introduce errors. For example a software tool that is overly complicated. In this instance the employee dissatisfaction is only an indicator for a hidden root cause.

An employee that is unsatisfied with his job, for whatever reason, is also more likely to leave the company. If the person was critical to the project this can have hugely detrimental effects. Furthermore, if enough key people leave, the entire project can be endangered. 
\section{Worthwhile risk / Low negative variance}
% Beginning of rewrite
Understandably, the world of safety-critical device manufacturers is a conservative one indeed. [...]

% REWRITE This section
Imagine two device architectures \textit{A} and \textit{B}. Architecture \textit{A} has the potential to create perfectly reusable software, much better than architecture \textit{B}. But it is possible that \textit{A} introduces expensive safety problems later in the development process.
In this case architecture \textit{A} has a much higher associated risk but also  some positive variance. This example is very abstract and some more concrete architectural risks will be introduced in future sections. 

Which risks are considered "worthwhile" is very dependent on other circumstances and even in this example it is not clear what would be the better architecture (even assuming that they have no other defining criteria). However, just considering the possible risks of architectures can give important insights into when they should be used.
[Example is confusing and section seems incomplete]
\section{Future-proof design}
Whenever there is an associated hardware , future-proof design is especially important. Software can be reproduced and shipped with practically no cost but devices can not. Any features that have been forgotten can only be added once the next major hardware revision is released.

Safety-critical devices are particularly notable in this respect, since they are often very complex and have an expensive engineering process. Airplanes are typically used for 3 decades and hospitals have notoriously tight budgets and have to squeeze as much lifetime out of their devices as possible. 
\subsection{Extendibility}
Nowadays it is becoming increasingly more plausible that it is possible to deliver software updates to an embedded device \cite{OndrejKachman.2016}. Along with the previously mentioned long life cycle it is a beneficial strategy [what do I mean by that], if not an expected service, to provide updates for the device.
If the device's hardware supports it, new features could be implemented but the currently more typical scenario are updates of a more basic kind. Meaning, bug fixes and security updates.

In any case an easily extendable device can have significant benefits.
\subsection{Maintainability}
% Relates to faults as described above but also changing functionality
[I ended up explaining a lot of this in the "faults" section, I am currently thinking about how to best reconcile that]
\subsection{Reusability}
This \textit{want} relates to another aspect of future oriented design. Towards the end of a device's life cycle, manufacturers are starting to plan the next generation with upgraded hardware and new features. If the software from the previous generation is reusable and suitably portable, a lot of time and money can be saved on this new generation.

Another scenario for this is the \textit{device platform}, where there is a core device and several variations for different markets. In this example it is presumably even easier to profit from reusable software.

The next device generation and another device on the same platform have the advantage that they presumably share most of the business logic with the original device. That makes reusing a lot of the software plausible. However, if the software is reusable, suitably generic software could conceivably even be used in entirely different devices.
%----------------------------------------------------------------------------------------